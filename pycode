#Unzipping the file
!tar -xf /content/drive/MyDrive/fer2013.tar.gz

from google.colab import drive
drive.mount('/content/drive')

//Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount("/content/drive", force_remount=True).

  
import keras
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, AveragePooling2D
from keras.layers import Dense, Activation, Dropout, Flatten

from keras.preprocessing import image
from keras.preprocessing.image import ImageDataGenerator

import numpy as np
import matplotlib.pyplot as plt

#------------------------------
#cpu - gpu configuration
config = tf.ConfigProto( device_count = {'GPU': 0 , 'CPU': 56} ) #max: 1 gpu, 56 cpu
sess = tf.Session(config=config) 
tf.keras.backend.set_session(sess)
#------------------------------
#variables
num_classes = 7 #angry, disgust, fear, happy, sad, surprise, neutral
batch_size = 128
epochs = 25
#------------------------------
#read kaggle facial expression recognition challenge dataset (fer2013.csv)
#https://www.kaggle.com/c/challenges-in-representation-learning-facial-expression-recognition-challenge

with open("fer2013/fer2013.csv") as f:
  content = f.readlines()

lines = np.array(content)

num_of_instances = lines.size
print("number of instances: ",num_of_instances)
print("instance length: ",len(lines[1].split(",")[1].split(" ")))

#------------------------------
#initialize trainset and test set
x_train, y_train, x_test, y_test = [], [], [], []

#------------------------------
#transfer train and test set data
for i in range(1,num_of_instances):
    try:
        emotion, img, usage = lines[i].split(",")
          
        val = img.split(" ")
            
        pixels = np.array(val, 'float32')
        
        emotion = keras.utils.to_categorical(emotion, num_classes)
    
        if 'Training' in usage:
            y_train.append(emotion)
            x_train.append(pixels)
        elif 'PublicTest' in usage:
            y_test.append(emotion)
            x_test.append(pixels)
    except:
      print("", end="")

#------------------------------
#data transformation for train and test sets
x_train = np.array(x_train, 'float32')
y_train = np.array(y_train, 'float32')
x_test = np.array(x_test, 'float32')
y_test = np.array(y_test, 'float32')

x_train /= 255 #normalize inputs between [0, 1]
x_test /= 255

x_train = x_train.reshape(x_train.shape[0], 48, 48, 1)
x_train = x_train.astype('float32')
x_test = x_test.reshape(x_test.shape[0], 48, 48, 1)
x_test = x_test.astype('float32')

print(x_train.shape[0], 'train samples')
print(x_test.shape[0], 'test samples')
#------------------------------
#construct CNN structure
model = Sequential()

#1st convolution layer
model.add(Conv2D(64, (5, 5), activation='relu', input_shape=(48,48,1)))
model.add(MaxPooling2D(pool_size=(5,5), strides=(2, 2)))

#2nd convolution layer
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(AveragePooling2D(pool_size=(3,3), strides=(2, 2)))

#3rd convolution layer
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(AveragePooling2D(pool_size=(3,3), strides=(2, 2)))

model.add(Flatten())

#fully connected neural networks
model.add(Dense(1024, activation='relu'))
model.add(Dropout(0.2))
model.add(Dense(1024, activation='relu'))
model.add(Dropout(0.2))

model.add(Dense(num_classes, activation='softmax'))
#------------------------------
#batch process
gen = ImageDataGenerator()
train_generator = gen.flow(x_train, y_train, batch_size=batch_size)

#------------------------------

model.compile(loss='categorical_crossentropy'
    , optimizer=keras.optimizers.Adam()
    , metrics=['accuracy']
)

#------------------------------

fit = True

if fit == True:
	#model.fit_generator(x_train, y_train, epochs=epochs) #train for all trainset
	model.fit_generator(train_generator, steps_per_epoch=batch_size, epochs=epochs) #train for randomly selected one
else:
	model.load_weights('/data/facial_expression_model_weights.h5') #load weights
	
#------------------------------
"""
#overall evaluation
score = model.evaluate(x_test, y_test)
print('Test loss:', score[0])
print('Test accuracy:', 100*score[1])
"""
#------------------------------
#function for drawing bar chart for emotion preditions
def emotion_analysis(emotions):
    objects = ('angry', 'disgust', 'fear', 'happy', 'sad', 'surprise', 'neutral')
    y_pos = np.arange(len(objects))
    
    plt.bar(y_pos, emotions, align='center', alpha=0.5)
    plt.xticks(y_pos, objects)
    plt.ylabel('percentage')
    plt.title('emotion')
    
    plt.show()
#------------------------------

//number of instances:  35888
instance length:  2304
28709 train samples
3589 test samples
Epoch 1/25
/usr/local/lib/python3.7/dist-packages/tensorflow/python/keras/engine/training.py:1844: UserWarning: `Model.fit_generator` is deprecated and will be removed in a future version. Please use `Model.fit`, which supports generators.
  warnings.warn('`Model.fit_generator` is deprecated and '
128/128 [==============================] - 3s 19ms/step - loss: 1.8404 - accuracy: 0.2414
Epoch 2/25
128/128 [==============================] - 2s 19ms/step - loss: 1.8220 - accuracy: 0.2432
Epoch 3/25
128/128 [==============================] - 2s 18ms/step - loss: 1.7973 - accuracy: 0.2437
Epoch 4/25
128/128 [==============================] - 2s 18ms/step - loss: 1.7208 - accuracy: 0.3002
Epoch 5/25
128/128 [==============================] - 2s 18ms/step - loss: 1.6240 - accuracy: 0.3550
Epoch 6/25
128/128 [==============================] - 2s 18ms/step - loss: 1.5605 - accuracy: 0.3805
Epoch 7/25
128/128 [==============================] - 2s 18ms/step - loss: 1.5339 - accuracy: 0.4016
Epoch 8/25
128/128 [==============================] - 2s 19ms/step - loss: 1.4754 - accuracy: 0.4256
Epoch 9/25
128/128 [==============================] - 2s 19ms/step - loss: 1.4418 - accuracy: 0.4361
Epoch 10/25
128/128 [==============================] - 2s 18ms/step - loss: 1.3912 - accuracy: 0.4604
Epoch 11/25
128/128 [==============================] - 2s 18ms/step - loss: 1.3653 - accuracy: 0.4790
Epoch 12/25
128/128 [==============================] - 2s 19ms/step - loss: 1.3293 - accuracy: 0.4895
Epoch 13/25
128/128 [==============================] - 2s 19ms/step - loss: 1.2987 - accuracy: 0.5062
Epoch 14/25
128/128 [==============================] - 2s 18ms/step - loss: 1.2536 - accuracy: 0.5213
Epoch 15/25
128/128 [==============================] - 2s 18ms/step - loss: 1.2531 - accuracy: 0.5249
Epoch 16/25
128/128 [==============================] - 2s 19ms/step - loss: 1.2246 - accuracy: 0.5394
Epoch 17/25
128/128 [==============================] - 2s 19ms/step - loss: 1.1972 - accuracy: 0.5469
Epoch 18/25
128/128 [==============================] - 2s 19ms/step - loss: 1.1831 - accuracy: 0.5553
Epoch 19/25
128/128 [==============================] - 2s 19ms/step - loss: 1.1602 - accuracy: 0.5595
Epoch 20/25
128/128 [==============================] - 2s 19ms/step - loss: 1.1437 - accuracy: 0.5678
Epoch 21/25
128/128 [==============================] - 2s 19ms/step - loss: 1.1259 - accuracy: 0.5692
Epoch 22/25
128/128 [==============================] - 2s 19ms/step - loss: 1.0991 - accuracy: 0.5814
Epoch 23/25
128/128 [==============================] - 2s 18ms/step - loss: 1.0964 - accuracy: 0.5865
Epoch 24/25
128/128 [==============================] - 2s 19ms/step - loss: 1.0678 - accuracy: 0.5994
Epoch 25/25
128/128 [==============================] - 2s 19ms/step - loss: 1.0505 - accuracy: 0.6048//........

model.save('model25.h5')

#Evaluation
train_score = model.evaluate(x_train, y_train, verbose=0)
print('Train loss:', train_score[0])
print('Train accuracy:', 100*train_score[1])
 
test_score = model.evaluate(x_test, y_test, verbose=0)
print('Test loss:', test_score[0])
print('Test accuracy:', 100*test_score[1])

//Train loss: 1.0166246891021729
Train accuracy: 61.266499757766724
Test loss: 1.2123886346817017
Test accuracy: 54.471999406814575//

#Confusion Matrix.

from sklearn.metrics import classification_report, confusion_matrix
 
pred_list = []; actual_list = []
predictions = model.predict(x_test)
#predictions=classifier.predict(x_test)
for i in predictions:
 
  pred_list.append(np.argmax(i))
 
for i in y_test:
 
  actual_list.append(np.argmax(i))
 
confusion_matrix(actual_list, pred_list)

//array([[292,   3,  11,  32,  70,  12,  47],
       [ 32,   7,   3,   2,   7,   0,   5],
       [128,   0,  66,  32, 131,  59,  80],
       [ 55,   0,   8, 686,  60,  14,  72],
       [152,   1,  28,  44, 285,  11, 132],
       [ 28,   1,  22,  24,  13, 300,  27],
       [ 96,   0,  15,  51, 118,   8, 319]])//
       
       monitor_testset_results = True

if monitor_testset_results == True:
	#make predictions for test set
	predictions = model.predict(x_test)

	index = 0
	for i in predictions:
		if index < 30 and index >= 20:
			#print(i) #predicted scores
			#print(y_test[index]) #actual scores
			
			testing_img = np.array(x_test[index], 'float32')
			testing_img = testing_img.reshape([48, 48]);
			
			plt.gray()
			plt.imshow(testing_img)
			plt.show()
			
			print(i)
			
			emotion_analysis(i)
			print("----------------------------------------------")
		index = index + 1
    
    monitor_testset_results = True

if monitor_testset_results == True:
	#make predictions for test set
	predictions = model.predict(x_test)

	index = 0
	for i in predictions:
		if index < 30 and index >= 20:
			#print(i) #predicted scores
			#print(y_test[index]) #actual scores
			
			testing_img = np.array(x_test[index], 'float32')
			testing_img = testing_img.reshape([48, 48]);
			
			plt.gray()
			plt.imshow(testing_img)
			plt.show()
			
			print(i)
			
			emotion_analysis(i)
			print("----------------------------------------------")
		index = index + 1
    
    def emotion_analysis(emotions):
    objects = ('angry', 'disgust', 'fear', 'happy', 'sad', 'surprise', 'neutral')
    y_pos = np.arange(len(objects))
    
    plt.bar(y_pos, emotions, align='center', alpha=0.5)
    plt.xticks(y_pos, objects)
    plt.ylabel('percentage')
    plt.title('emotion')
    
    plt.show()
    
    #Testing a file.

from keras.preprocessing import image
from keras.preprocessing.image import ImageDataGenerator

import numpy as np
import matplotlib.pyplot as plt


file = 'capture.jpg'
true_image = image.load_img(file)
img = image.load_img(file, grayscale=True, target_size=(48, 48))

x = image.img_to_array(img)
x = np.expand_dims(x, axis = 0)

x /= 255

custom = model.predict(x)
emotion_analysis(custom[0])

x = np.array(x, 'float32')
x = x.reshape([48, 48]);

plt.gray()
plt.imshow(true_image)
plt.show()

import cv2
            
def facecrop(image):  
    facedata = "haarcascade_frontalface_default.xml"
    cascade = cv2.CascadeClassifier(cv2.data.haarcascades +facedata)

    img = cv2.imread(image)

    try:
    
        minisize = (img.shape[1],img.shape[0])
        miniframe = cv2.resize(img, minisize)

        faces = cascade.detectMultiScale(miniframe)

        for f in faces:
            x, y, w, h = [ v for v in f ]
            cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2)

            sub_face = img[y:y+h, x:x+w]

            
            cv2.imwrite('capture.jpg', sub_face)
            #print ("Writing: " + image)

    except Exception as e:
        print (e)

    #cv2.imshow(image, img)


if __name__ == '__main__':
    facecrop('photo.jpg')
    
    import cv2
            
def facecrop(image):  
    facedata = "haarcascade_frontalface_default.xml"
    cascade = cv2.CascadeClassifier(cv2.data.haarcascades +facedata)

    img = cv2.imread(image)

    try:
    
        minisize = (img.shape[1],img.shape[0])
        miniframe = cv2.resize(img, minisize)

        faces = cascade.detectMultiScale(miniframe)

        for f in faces:
            x, y, w, h = [ v for v in f ]
            cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2)

            sub_face = img[y:y+h, x:x+w]

            
            cv2.imwrite('capture.jpg', sub_face)
            #print ("Writing: " + image)

    except Exception as e:
        print (e)

    #cv2.imshow(image, img)


if __name__ == '__main__':
    facecrop('photo.jpg')
    
    take_photo()
